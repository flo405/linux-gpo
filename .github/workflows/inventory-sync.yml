name: Sync Device Inventory from ZITADEL v2 (direct, with PR fallback)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "*/30 * * * *"

permissions:
  contents: write
  pull-requests: write

env:
  GROUP_DEFAULT: laptops
  ZITADEL_BASE: ${{ secrets.ZITADEL_BASE }}                 # e.g., https://access.pny.at
  ZITADEL_ORG_DOMAIN: ${{ secrets.ZITADEL_ORG_DOMAIN }}     # optional
  ZITADEL_ORG_ID: ${{ secrets.ZITADEL_ORG_ID }}             # optional

jobs:
  inventory:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Use a PAT with "contents:write" if you want to bypass stricter branch protections
          token: ${{ secrets.BOT_TOKEN || github.token }}

      - name: Tooling
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq
          curl -fsSL https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64 -o yq
          sudo install -m 0755 yq /usr/local/bin/yq
          jq --version; yq --version

      - name: Env sanity
        run: |
          echo "ZITADEL_BASE=${ZITADEL_BASE:-<unset>}"
          test -n "${{ secrets.ZITADEL_CLIENT_ID }}" && echo "CLIENT_ID set" || echo "CLIENT_ID MISSING"
          test -n "${{ secrets.ZITADEL_CLIENT_SECRET }}" && echo "CLIENT_SECRET set" || echo "CLIENT_SECRET MISSING"

      - name: Obtain service token (client credentials)
        id: token
        env:
          TOKEN_URL: ${{ env.ZITADEL_BASE }}/oauth/v2/token
          CLIENT_ID: ${{ secrets.ZITADEL_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.ZITADEL_CLIENT_SECRET }}
          SCOPE: ${{ secrets.ZITADEL_SCOPE }}  # e.g.: openid profile urn:zitadel:iam:org:project:id:zitadel:aud
        run: |
          set -euo pipefail
          mkdir -p inventory/meta
          if [ -z "${TOKEN_URL:-}" ] || [ -z "${CLIENT_ID:-}" ] || [ -z "${CLIENT_SECRET:-}" ]; then
            echo "token=" >> "$GITHUB_OUTPUT"
            jq -n '{details:{totalResult:"0"},result:[]}' > inventory/users.list.json
            exit 0
          fi
          TOK_JSON="$(curl -sS -u "$CLIENT_ID:$CLIENT_SECRET" \
            -H 'content-type: application/x-www-form-urlencoded' \
            --data-urlencode 'grant_type=client_credentials' \
            ${SCOPE:+--data-urlencode "scope=$SCOPE"} \
            "$TOKEN_URL" || true)"
          AT="$(jq -r '.access_token // empty' <<<"$TOK_JSON")" || AT=""
          if [ -z "$AT" ]; then
            echo "WARN: No access_token from ZITADEL. Writing empty users list and continuing."
            echo "$TOK_JSON" > inventory/token_error.json
            echo "token=" >> "$GITHUB_OUTPUT"
            jq -n '{details:{totalResult:"0"},result:[]}' > inventory/users.list.json
            exit 0
          fi
          echo "token=$AT" >> "$GITHUB_OUTPUT"

      - name: Search users (POST /v2/users)
        id: users
        env:
          AT: ${{ steps.token.outputs.token }}
          API: ${{ env.ZITADEL_BASE }}/v2/users
          ORG_DOMAIN: ${{ env.ZITADEL_ORG_DOMAIN }}
          ORG_ID: ${{ env.ZITADEL_ORG_ID }}
        run: |
          set -euo pipefail
          mkdir -p inventory
          if [ -z "${AT:-}" ] || [ -z "${API:-}" ]; then
            jq -n '{details:{totalResult:"0"},result:[]}' > inventory/users.list.json
            exit 0
          fi
          BODY='{"limit":200}'
          HDRS=(-H "authorization: Bearer $AT" -H "content-type: application/json")
          [ -n "${ORG_DOMAIN:-}" ] && HDRS+=(-H "x-zitadel-org-domain: $ORG_DOMAIN")
          [ -n "${ORG_ID:-}" ] && HDRS+=(-H "x-zitadel-org-id: $ORG_ID")
          if ! curl -sS -X POST "$API" "${HDRS[@]}" -d "$BODY" > inventory/users.list.json; then
            echo 'WARN: user search failed; falling back to empty list'
            jq -n '{details:{totalResult:"0"},result:[]}' > inventory/users.list.json
          fi
          jq -e '.' inventory/users.list.json >/dev/null || echo 'WARN: users.list.json not valid JSON (continuing)'
          echo "Users returned: $(jq -r '.details.totalResult // 0' inventory/users.list.json)"

      - name: Fetch per-user metadata (POST /v2/users/:id/metadata/search)
        env:
          AT: ${{ steps.token.outputs.token }}
          BASE: ${{ env.ZITADEL_BASE }}
          ORG_DOMAIN: ${{ env.ZITADEL_ORG_DOMAIN }}
          ORG_ID: ${{ env.ZITADEL_ORG_ID }}
        run: |
          set -euo pipefail
          : > inventory/user_ids.txt
          jq -r '.result[]?.userId' inventory/users.list.json 2>/dev/null | sort -u > inventory/user_ids.txt || true
          COUNT=$(wc -l < inventory/user_ids.txt | tr -d ' ')
          echo "User IDs to fetch metadata for: $COUNT"

          if [ "$COUNT" -gt 0 ] && [ -n "${AT:-}" ] && [ -n "${BASE:-}" ]; then
            while read -r UID; do
              [ -z "$UID" ] && continue
              HDRS=(-H "authorization: Bearer $AT" -H "content-type: application/json")
              [ -n "${ORG_DOMAIN:-}" ] && HDRS+=(-H "x-zitadel-org-domain: $ORG_DOMAIN")
              [ -n "${ORG_ID:-}" ] && HDRS+=(-H "x-zitadel-org-id: $ORG_ID")
              curl -sS -X POST "$BASE/v2/users/$UID/metadata/search" \
                "${HDRS[@]}" -d '{}' > "inventory/meta/$UID.json" || echo '{}' > "inventory/meta/$UID.json"
            done < inventory/user_ids.txt
          fi

      - name: Join & render inventory/devices.yml (decode base64 metadata)
        run: |
          set -euo pipefail

          jq -n '
            def kv_map(md):
              (md.result // md.items // [])
              | map({ ( .key // .name // "" ): ( try (.value | @base64d) catch (.value // "") ) })
              | add;

            def norm_user(u):
              {
                userId: (u.userId // "unknown"),
                identity: (
                  u.human.email.email
                  // u.preferredLoginName
                  // u.username
                  // u.machine.name
                  // "unknown"
                )
              };

            (input | .result // []) as $U
            | [ $U[]? as $u
                | ($u.userId // empty) as $uid
                | (try (input | fromjson) catch {}) as $md
                | (norm_user($u) + {meta: kv_map($md)})
              ]
          ' \
          < inventory/users.list.json \
          $(for u in $(jq -r '.result[]?.userId' inventory/users.list.json | sort -u); do printf "inventory/meta/%s.json " "$u"; done) \
          > inventory/joined.json || echo '[]' > inventory/joined.json

          echo "Joined rows: $(jq 'length' inventory/joined.json)"

          jq '
            {
              apiVersion: "lgpo.io/v1",
              kind: "DeviceInventory",
              items:
                ( [ .[] as $r
                    | ($r.meta.lgpo_device_ids // "[]"  | try (fromjson) catch []) as $ids
                    | ($r.meta.lgpo_device_tags // "{}" | try (fromjson) catch {}) as $dtag
                    | $ids[]
                    | {
                        device_pub_sha256: .,
                        identity: $r.identity,
                        tags:
                          (
                            ($dtag[.] // {}) as $dt
                            | if (env.GROUP_DEFAULT // "") != "" and (($dt.group // empty) | not)
                              then ($dt + {group: env.GROUP_DEFAULT})
                              else $dt end
                          )
                      }
                  ]
                  | unique_by(.device_pub_sha256)
                  | sort_by(.device_pub_sha256)
                )
            }' inventory/joined.json \
          | yq -P > inventory/devices.yml

          echo "devices.yml preview:"
          sed -n '1,200p' inventory/devices.yml || true

      - name: Upload debug artifact (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: inventory-debug
          path: |
            inventory/users.list.json
            inventory/user_ids.txt
            inventory/meta/*.json
            inventory/joined.json
            inventory/devices.yml
          if-no-files-found: warn
          retention-days: 3

      - name: Commit & push to default branch (with fallback to PR)
        id: push
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
          PUSH_TOKEN: ${{ secrets.BOT_TOKEN || github.token }}
        run: |
          set -euo pipefail
          BR="${DEFAULT_BRANCH:-main}"
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git fetch origin "$BR"
          git checkout "$BR"
          git pull --rebase origin "$BR"

          git add inventory/devices.yml inventory/users.list.json inventory/meta || true
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          git commit -m "chore(inventory): sync from ZITADEL v2 [skip ci]"

          # Ensure remote uses a token (avoids 'could not read Username' errors)
          git remote set-url origin "https://x-access-token:${PUSH_TOKEN}@github.com/${{ github.repository }}.git"

          set +e
          git push --verbose origin HEAD:"$BR"
          RC=$?
          set -e
          echo "rc=$RC" >> "$GITHUB_OUTPUT"

      - name: Create PR (fallback if push failed)
        if: steps.push.outputs.rc != '0'
        uses: peter-evans/create-pull-request@v6
        with:
          title: "Sync inventory/devices.yml (fallback PR)"
          body: "Direct push failed (likely branch protection). This PR contains the inventory update."
          commit-message: "chore(inventory): sync from ZITADEL v2"
          branch: ci/inventory-sync
          base: ${{ github.event.repository.default_branch }}
          add-paths: |
            inventory/devices.yml
            inventory/users.list.json
            inventory/meta
